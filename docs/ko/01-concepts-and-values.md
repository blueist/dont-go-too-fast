# DGTF++: 핵심 개념

## 문제: What이 아니라 How

**Clean Code를 읽었는가?**   
**SOLID 원칙을 아는가?**   
**TDD를 들어봤는가?**   

아마 "네"일 것이다.

**그런데 왜 금요일 오후 마감 앞에서 전역 변수를 쓰는가?**

```
많은 개발자:
"Clean Code? 알아요"
"SOLID? 알죠"
"TDD? 들어봤어요"

현실:
금요일 오후 5시
매니저: "이거 언제 되나요?"
→ "일단 전역 변수로..."
→ "하드코딩하면 빨리..."
→ "테스트? 나중에..."
```

**문제는 "What"을 모르는 게 아니다.**
**문제는 "How"를 모르는 것이다.**

- What: Clean Code, SOLID, TDD (이미 안다)
- How: 압박 속에서 어떻게 지키는가? (이것이 필요하다)

**ROD, TFD, DGTF는 "How"에 대한 답이다.**

이 방법론은 새로운 "What"이 아니다.
좋은 개발을 **"왜"**, **"언제"**, **"어떻게"** 해야 하는지에 대한 답이다.

---

## 이론적 기반

이 방법론은 세 가지 검증된 이론 위에 세워졌다. 이 이론들을 이해하는 것은 필수다—학술적 지식으로서가 아니라, DGTF++가 왜 작동하는지의 기반으로서.

---

### Daniel Kahneman: 왜 압박에서 실패하는가

**노벨상을 받은 통찰:**

Daniel Kahneman은 인간의 의사결정이 합리적이지 않다는 것을 증명하여 2002년 노벨 경제학상을 받았다. 그의 연구는 두 가지 뚜렷한 사고 시스템을 밝혀냈다:

**System 1 (빠른 사고)**

```
특성:
- 자동적이고 무의식적
- 노력이 필요 없음
- 항상 작동 중
- 패턴 매칭 기반
- 감정적

강점:
- 즉각적 반응
- 에너지 효율적
- 익숙한 상황에 적합
- 우리를 살게 함 (투쟁 또는 도피)

약점:
- 인지 편향에 취약
- 성급한 결론
- 복잡성 처리 못함
- 압박에서 실수
- 과신
```

**System 2 (느린 사고)**

```
특성:
- 의도적이고 의식적
- 노력과 집중 필요
- 의도적으로 활성화해야 함
- 논리와 추론 기반
- 분석적

강점:
- 정확한 판단
- 복잡성 처리 가능
- 여러 요소 고려
- 장기적 사고
- 자기 인식

약점:
- 느림
- 피곤함 (정신 에너지 소모)
- 게으름 (활성화 회피)
- 압박에서 꺼짐
- 제한된 용량
```

**핵심 발견:**

> System 2는 게으르다. 강제하지 않으면 활성화되지 않는다.
> 압박 하에서 System 2는 완전히 꺼지고, System 1이 완전히 제어한다.

**소프트웨어 개발에서의 의미:**

| 상황 | 시스템 | 전형적 결정 |
|------|--------|-------------|
| 차분한 설계 회의 | System 2 | "엣지 케이스 생각해보자" |
| 금요일 오후 5시, 월요일 마감 | System 1 | "일단 하드코딩하자" |
| 코드 리뷰, 압박 없음 | System 2 | "SRP 위반이네, 리팩터링하자" |
| 프로덕션 다운 | System 1 | "일단 서버 재시작" |
| 새 개념 학습 | System 2 | "완전히 이해해보자" |
| 이 시간에 세 번째 버그 | System 1 | "if문 하나 더 추가" |

**개발자의 딜레마:**

```
설계 단계:
- 시간 여유
- 낮은 압박
- System 2 활성
- 좋은 결정 가능

구현 단계:
- 마감 압박
- 변경되는 요구사항
- System 1이 지배
- "빠른 수정"이 쌓임

결과:
아름다운 아키텍처를 설계한 바로 그 개발자가
압박 하에서 스파게티 코드를 작성한다.
더 좋은 방법을 몰라서가 아니다.
System 1은 "더 좋은 것"을 신경 쓰지 않기 때문이다.
```

**DGTF++의 활용:**

1. **ROD:** System 2가 활성화되어 있을 때 설계를 완료한다. System 1이 결정할 것을 남기지 않는다.

2. **TFD:** System 2가 활성화되어 있을 때 테스트를 정의한다. 구현은 기계적이 된다—그냥 테스트를 통과시키면 됨.

3. **DGTF:** System 1이 지배하려 할 때 인식한다. 압박 속에서도 System 2 활성화를 강제한다.

---

### Donella Meadows: 왜 전체를 봐야 하는가

**시스템 사고의 선구자:**

Donella Meadows는 복잡한 시스템을 이해하는 데 가장 영향력 있는 책 중 하나인 "Thinking in Systems"를 쓴 시스템 과학자다. 그녀의 통찰은 왜 개별 컴포넌트가 잘 만들어졌는데도 소프트웨어 프로젝트가 실패하는지를 설명한다.

**시스템이란 무엇인가?**

> 시스템은 목적을 달성하기 위해 조직된 상호 연결된 요소들의 집합이다.
> 전체는 부분의 합보다 크다.

**예시:**

```
자동차는 단순한 부품이 아니다:
- 엔진 + 바퀴 + 핸들 + 브레이크 = 이동 수단
- 어떤 부품이든 제거 = 이동 수단 아님
- 목적이 연결에서 나온다

소프트웨어도 마찬가지:
- UserService + AuthService + Database = 로그인 기능
- 어떤 부분이든 제거 = 로그인 안 됨
- 행동이 연결에서 나온다
```

**시스템 사고의 핵심 원칙:**

**1. 전체를 먼저 보라**

```
잘못된 접근:
"UserService부터 만들고, 나머지는 나중에 파악하지"
→ 구현 중 빠진 조각 발견
→ 패닉 → System 1 → 나쁜 결정

올바른 접근 (ROD):
"먼저 완전한 서비스 체인을 그리자"
→ 설계에서 모든 조각 파악
→ 구현은 알려진 조각을 만드는 것일 뿐
```

**2. 관계가 부품보다 중요하다**

```
잘 설계된 서비스 + 나쁜 연결 = 나쁜 시스템
단순한 서비스 + 좋은 연결 = 좋은 시스템

ROD가 집중하는 것:
- 서비스가 어떻게 연결되는지 (인터페이스)
- 그 사이에 뭐가 흐르는지 (데이터)
- 누가 누구에게 의존하는지 (의존성)
```

**3. 피드백 루프가 행동을 결정한다**

```
양성 피드백 (증폭):
버그 → 스트레스 → 급함 → 더 많은 버그 → 더 많은 스트레스 → ...
→ 시스템이 통제 불능으로

음성 피드백 (안정화):
코드 → 테스트 → 실패 → 수정 → 테스트 → 통과
→ 시스템이 자기 교정

TFD가 음성 피드백 루프를 만든다:
모든 변경이 즉시 검증된다.
문제가 증폭되기 전에 잡힌다.
```

**4. 레버리지 포인트: 어디에 개입할 것인가**

Meadows는 어떤 개입 지점이 다른 것보다 훨씬 효과적이라는 것을 밝혔다:

```
낮은 레버리지 (비싸고 영향 적음):
- 프로덕션에서 버그 수정
- 코드 작성 후 테스트 추가
- 레거시 코드 리팩터링

높은 레버리지 (싸고 영향 큼):
- 설계 단계 결정
- 코드 전에 테스트 정의
- 서비스 경계 일찍 확립

ROD + TFD는 가장 높은 레버리지 포인트에서 작동:
설계 단계.
```

**5. "Missing"의 위험**

```
요소가 빠진 시스템은 "대부분" 작동하는 게 아니다.
예측 불가능하게 행동한다.

예시:
에러 처리 없는 결제 시스템:
- 99% 시간은 작동
- 1% 실패가 데이터를 조용히 손상
- 몇 달 후에 발견
- 피해가 치명적

ROD의 "있는 게 없는 것보다 낫다":
에러 처리를 설계하고 제거하는 게
잊어버리고 프로덕션에서 발견하는 것보다 낫다.
```

**빙산 모델:**

```
보이는 것:     사건 (버그, 지연, 실패)
                    ↑
원인:          패턴 (반복되는 문제)
                    ↑
형성하는 것:    구조 (아키텍처, 프로세스)
                    ↑
근본:          멘탈 모델 (우리가 생각하는 방식)

대부분의 수정은 사건을 다룬다.
DGTF++는 멘탈 모델을 다룬다.
그래서 근본에서 작동한다.
```

**DGTF++의 활용:**

1. **ROD:** 부품을 만들기 전에 전체 시스템(서비스 체인)을 본다. 빠진 조각 없음.

2. **TFD:** 안정화 피드백 루프를 만든다. 모든 변경이 즉시 검증된다.

3. **DGTF:** 가장 높은 레버리지 포인트에서 작업한다—당신 자신의 사고 패턴.

---

### Genrich Altshuller: 왜 타협이 아닌 해결이어야 하는가

**TRIZ의 아버지:**

Genrich Altshuller는 20만 개 이상의 특허를 분석하여 혁신의 패턴을 발견한 소비에트 엔지니어다. 그의 발견: **획기적인 해결책은 타협이 아닌 모순 해결에서 나온다.**

**모순이란 무엇인가?**

> 한 측면을 개선하면 다른 측면이 나빠질 때 모순이 존재한다.

**소프트웨어의 근본적 모순:**

```
"빠른 개발을 원한다"
    vs
"높은 품질을 원한다"

전통적 "해결책" (사실은 타협):
- 빠르게 → 품질 희생 (기술 부채)
- 품질 → 속도 희생 (마감 놓침)
- 균형 → 둘 다 못 얻음 (모든 게 평범)

이 중 어떤 것도 해결책이 아니다.
이것들은 항복이다.
```

**TRIZ의 혁명적 통찰:**

> 모순은 균형 잡아야 할 문제가 아니다.
> 모순은 혁신의 기회다.

**40가지 발명 원리:**

Altshuller는 발명가들이 반복적으로 사용하는 40가지 원리를 파악했다. 세 가지가 소프트웨어에 특히 관련된다:

**원리 1: 분할 (Segmentation)**

```
문제: 모놀리식 시스템은 변경하기 어렵다
타협: 변경이 위험하다는 것을 받아들임

TRIZ 해결: 독립적인 세그먼트로 분할
→ 명확한 경계를 가진 서비스들
→ 다른 것에 영향 없이 하나 변경
→ ROD의 서비스 체인
```

**원리 10: 사전 조치 (Prior Action)**

```
문제: 구현 중 문제 발견
타협: 디버깅이 개발의 일부라는 것을 받아들임

TRIZ 해결: 필요하기 전에 미리 하기
→ 구현 전 완전히 설계
→ 코드 전 테스트 작성
→ ROD + TFD
```

**원리 15: 동적화 / 시간 분리 (Dynamization)**

```
문제: 빠르면서 동시에 신중해야 함
타협: 어느 정도 빠르고, 어느 정도 신중 (둘 다 아님)

TRIZ 해결: 다른 시간에 다른 것이 되기
→ 설계 단계: 느리고 철저 (100% 신중)
→ 구현 단계: 빠른 실행 (100% 빠름)
→ DGTF++ 접근법
```

**분리 원리:**

TRIZ는 모순을 해결하는 네 가지 방법을 제시한다:

```
1. 시간 분리
   "빠르면서 신중하게" → 지금은 신중, 나중에 빠르게
   → 설계는 느리게, 구현은 빠르게

2. 공간 분리
   "결합되면서 독립적" → 다른 경계
   → 서비스는 독립적, 시스템은 결합

3. 스케일 분리
   "단순하면서 완전" → 다른 레벨
   → 각 서비스 단순, 전체 시스템 완전

4. 조건 분리
   "유연하면서 안정적" → 다른 트리거
   → 인터페이스 안정, 구현 유연
```

**이상적 최종 결과 (Ideal Final Result):**

Altshuller가 물었다: "이상적인 해결책은 어떻게 생겼을까?"

```
이상적인 소프트웨어 개발:
- 버그 제로
- 재작업 제로
- 혼란 제로
- 즉각 완료

어떻게 접근하나:
- 버그는 빠진 설계에서 → 완전한 설계 (ROD)
- 재작업은 불명확한 요구사항에서 → 테스트가 요구사항 (TFD)
- 혼란은 System 1에서 → System 1 통제 (DGTF)
- 느린 완료는 실수 수정에서 → 실수 방지 (세 가지 모두)
```

**DGTF++의 활용:**

1. **ROD:** 사전 조치 + 분할. 구현 전 모든 것 설계. 독립적 서비스로 분할.

2. **TFD:** 사전 조치. 만들기 전 성공 기준 정의.

3. **DGTF:** 시간 분리. 먼저 생각 (System 2), 그다음 행동 (빠를 수 있음).

---

### 왜 이 세 가지가 함께인가

각 이론은 다른 질문에 답한다:

```
Kahneman → "왜 압박에서 실패하는가?"
           답: System 1이 지배하고 나쁜 결정을 내린다.

Meadows  → "실패를 방지하려면 무엇을 준비해야 하는가?"
           답: 피드백 루프를 가진 완전한 시스템.

TRIZ     → "속도와 품질을 어떻게 둘 다 얻는가?"
           답: 분리를 통해 모순을 해결.
```

**통합:**

```
┌─────────────────────────────────────────────────────────────┐
│                    DGTF++ 프레임워크                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Kahneman: 언제 생각할 것인가                               │
│  ─────────────────────────                                  │
│  설계 단계 = System 2 시간                                  │
│  구현 = System 1으로부터 보호                               │
│                                                             │
│  Meadows: 무엇을 생각할 것인가                              │
│  ────────────────────────────                               │
│  전체 시스템을 보라                                         │
│  피드백 루프를 만들라                                       │
│  높은 레버리지 포인트에서 작업하라                          │
│                                                             │
│  TRIZ: 모순을 어떻게 해결할 것인가                          │
│  ───────────────────────────────                            │
│  생각과 실행을 시간으로 분리                                │
│  독립적 서비스로 분할                                       │
│  사전 조치 적용                                             │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ROD  = Meadows (전체 시스템) + TRIZ (사전 조치)            │
│  TFD  = Meadows (피드백) + TRIZ (사전 조치)                 │
│  DGTF = Kahneman (System 2) + TRIZ (시간 분리)              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**어떤 이론 하나만으로는 충분하지 않다:**

- Meadows 없이 Kahneman: 언제 생각할지 알지만, 무엇을 생각할지 모름
- TRIZ 없이 Meadows: 무엇을 준비할지 알지만, 타협에 갇힘
- Kahneman 없이 TRIZ: 어떻게 해결할지 알지만, 압박에서 실행 못함

**함께, 지속 가능한 소프트웨어 개발을 위한 완전한 시스템을 형성한다.**

---

## ROD: Responsibility-Oriented Design

### 핵심 원칙

> **"있는 게 없는 것보다 낫다" (More is better than missing)**

설계 단계에서 **완전한 서비스 체인**을 만들어라.

새 서비스를 만들지 말지 헷갈릴 때—**만들어라**.

왜? 체인이 빠져있고 구현 중에 발견하면, **System 1이 그 상황을 좋아할 것이다**. 그리고 System 1이 좋아한다는 것은 나쁜 급한 결정을 의미한다.

### 비대칭성: 제거 vs 추가

이 원칙은 근본적인 비대칭성에 기반한다:

**구현 중 불필요한 서비스 제거:**
```
상황: "이 서비스 호출되는 곳이 없네"
증거: 명확함 (사용 안 됨)
정신 상태: 차분함 (System 2)
행동: 삭제
위험: 낮음
노력: 쉬움
```

**구현 중 빠진 서비스 추가:**
```
상황: "이게 필요한데 없잖아!"
증거: 패닉 발견
정신 상태: 압박 (System 1 지배)
행동: 빠른 땜질
위험: 높음
노력: 어려움 그리고 위험함
```

**비대칭성이 명확하다:**
- 제거 = 쉬움, 안전함, System 2
- 추가 = 어려움, 위험함, System 1

**따라서:** 설계 중 헷갈리면 포함시켜라. 나중에 언제든 제거할 수 있다.

### 서비스 체인이란?

서비스 체인은 요구사항을 충족하는 데 필요한 모든 서비스와 그 관계의 완전한 지도다.

```
예: "사용자가 상품을 구매할 수 있다"

서비스 체인:
UserService → CartService → PaymentService → OrderService → InventoryService → NotificationService

각 화살표 = 의존성
각 서비스 = 명확한 책임
완전한 체인 = 구현 중 놀람 없음
```

**핵심 질문:**
> "이 요구사항이 서비스 체인만으로 달성될 수 있는가?"

- YES → 체인 완전
- NO → 뭔가 빠짐 → 설계 단계에서 서비스 추가 (구현 단계가 아니라!)

### ROD는 새로운 "What"이 아니다

솔직해지자.

**ROD는 완전히 새로운 게 아니다:**
- Clean Architecture? 비슷하다.
- Service-Oriented Design? 그렇다.
- Domain-Driven Design? 겹치는 부분이 있다.
- SOLID? 포함되어 있다.

**하지만 질문:**

Clean Architecture를 안다.
SOLID를 안다.
의존성 주입을 안다.

**그런데 왜 마감이 다가오면 지키지 못하는가?**
**왜 "일단 되게 하고 나중에 고치자"가 되는가?**

**ROD는 새로운 기술이 아니다.**  
ROD는 좋은 설계를 **"왜"**, **"언제"**, **"어떻게"** 해야 하는지에 대한 답이다.

```
Clean Architecture:
"이렇게 구조화해라"
→ What (무엇을 할지)

ROD:
"왜 이렇게 해야 하는지" (Kahneman: System 1 방지)
"언제 이렇게 해야 하는지" (설계 단계, System 2가 활성화될 때)
"어떻게 유지하는지" (완전한 서비스 체인, Missing 없음)
→ Why + When + How
```

### 진짜 힘: 변경 격리

아무리 완벽하게 설계해도, 구현 중 변경은 일어난다.

- 요구사항 변경
- 더 좋은 방법 발견
- 버그 수정 필요

**ROD는 변경을 막지 않는다. ROD는 변경을 격리한다.**

```
ROD 없이 (강결합):
A 변경 → B에 영향 → C에 영향 → D에 영향 → ...
→ 변경이 두려움
→ "건드리지 마, 동작하잖아"
→ 기술 부채 축적

ROD로 (서비스 체인):
A 변경 → A의 인터페이스 유지 → B, C, D 영향 없음
→ 변경이 안전함
→ 자신 있게 리팩터링
→ 지속 가능한 코드베이스
```

**서비스 체인이 경계를 만든다.**
각 서비스는 명확한 책임이 있다.
서비스 내부의 변경은 외부로 새지 않는다.

### 엄격한 규칙

서비스 체인 무결성을 유지하기 위해:

- ❌ 서비스 내부에서 생성자(new) 금지
- ❌ Static 필드나 메서드 금지
- ❌ 구현에 대한 가정 금지
- ✅ 모든 것을 서비스로 표현
- ✅ 의존성은 주입, 생성하지 않음

왜 이런 규칙인가? 왜냐하면:
- `new`는 숨겨진 의존성을 만든다 (체인 가시성 파괴)
- `static`은 전역 상태를 만든다 (격리 파괴)
- 가정은 놀람이 된다 (System 1 트리거)

### ROD가 완전할 때

**검증 기준:**

```
각 요구사항에 대해 묻기:
"서비스 체인만으로 이것이 달성될 수 있는가?"

모든 요구사항에 YES → ROD 완전
어떤 요구사항에 NO → Missing 존재 → 설계에 추가
```

**완전한 ROD의 징후:**

- 모든 서비스가 정확히 하나의 책임을 가짐
- 모든 의존성이 체인에서 보임
- 어떤 서비스도 다른 서비스의 구현을 알 필요 없음
- 요구사항이 서비스 체인에 직접 대응
- 구현은 "체인을 따라가기만 하면 됨"

---

## TFD: Test-First Development

### 핵심 원칙

> **"요구사항 = 테스트"**

테스트를 작성할 수 없다면, 요구사항을 이해하지 못한 것이다.

테스트는 사후 검증이 아니다.
테스트는 요구사항이 무엇을 의미하는지의 **정밀한 정의**다.

### 왜 요구사항이 테스트여야 하는가

**자연어 요구사항의 문제:**

```
요구사항: "사용자가 로그인할 수 있어야 한다"

이것이 답하지 않는 질문들:
- 틀린 비밀번호면 어떻게 되나?
- 잠금 전까지 몇 번 시도 가능한가?
- "로그인됨"이 뭘 의미하나? 토큰? 세션? 쿠키?
- 만료된 계정은?
- 인증 안 된 이메일은?
```

**같은 요구사항을 테스트로:**

```
test_login_success:
  Given: 유효한 이메일, 올바른 비밀번호, 인증된 계정
  When: 로그인 시도
  Then: JWT 토큰 반환, 24시간 유효

test_login_wrong_password:
  Given: 유효한 이메일, 틀린 비밀번호
  When: 로그인 시도
  Then: 401 반환, 메시지 "잘못된 자격증명"
  
test_login_account_locked:
  Given: 연속 3회 실패
  When: 올바른 비밀번호로 4번째 시도
  Then: 403 반환, 메시지 "30분간 계정 잠금"

test_login_unverified_email:
  Given: 유효한 자격증명, 이메일 미인증
  When: 로그인 시도
  Then: 403 반환, 메시지 "이메일을 인증해주세요"
```

**이제 요구사항이 정밀하다.**
모호함 없음. 구현 중 놀람 없음.

### 테스트는 완료 기준이다

테스트 없이 "완료"는 주관적이다:
```
개발자: "끝났어요"
QA: "이 케이스 처리 안 되는데요"
개발자: "요구사항에 없었어요"
QA: "당연한 거잖아요"
개발자: "저한텐 아닌데요"
→ 충돌, 재작업, 좌절
```

TFD로 "완료"는 객관적이다:
```
모든 테스트 통과 → 완료
테스트 하나라도 실패 → 미완료
새 케이스 발견 → 먼저 테스트 추가, 그다음 구현
```

**테스트는 요구사항과 구현 사이의 계약이다.**

### TFD와 ROD의 결합

TFD는 ROD와 결합할 때 강력해진다:

```
ROD가 제공: 완전한 서비스 체인
TFD가 제공: 각 서비스에 대한 테스트

함께:
- 체인의 각 서비스가 테스트를 가짐
- 테스트가 서비스의 계약을 정의
- 구현은 그냥 계약을 이행
```

**예:**

```
ROD 서비스 체인:
UserService → AuthService → TokenService

TFD 테스트:
UserService:
  - test_find_by_email_exists
  - test_find_by_email_not_found
  
AuthService:
  - test_validate_password_correct
  - test_validate_password_wrong
  - test_check_account_status_active
  - test_check_account_status_locked
  
TokenService:
  - test_generate_token_valid_user
  - test_token_contains_required_claims
  - test_token_expires_in_24_hours
```

**구현할 때, 그냥 테스트를 통과시키는 것이다.**
추측 없음. 모호함 없음. System 1 결정 없음.

### TDD와의 관계

TFD는 TDD를 대체하지 않는다. TFD는 TDD를 쉽게 만든다.

**TDD의 흔한 어려움:**

```
TDD가 말함: "테스트 먼저 작성해"
개발자 생각: "뭘 테스트하지? 아직 뭘 만들지도 모르는데"
→ 코드 먼저 작성
→ TDD 포기
```

**TFD가 해결:**

```
ROD: 서비스 체인 정의 (어떤 서비스가 존재하는지)
TFD: 각 서비스에 대한 테스트 정의 (각 서비스가 뭘 하는지)
TDD: Red → Green → Refactor (어떻게 구현하는지)
```

**진행 순서:**

```
설계 단계 (System 2):
  1. ROD: 서비스 체인 구축
  2. TFD: 각 서비스에 대한 테스트 케이스 작성
  
구현 단계 (DGTF가 System 2 보호):
  3. TDD: 각 테스트에 대해 Red → Green → Refactor
```

**TFD가 TDD 시작 전에 "뭘 테스트할지"를 답한다.**

### 테스트는 즉각적 피드백을 제공한다

Meadows의 시스템 사고에서:
> "피드백 루프가 길수록 배우기 어렵다."

**테스트 없이 (긴 피드백 루프):**
```
코드 작성 → 배포 → 사용자가 버그 보고 → 디버깅 → 원인 찾기 → 수정
시간: 며칠에서 몇 주
학습: 어려움, 맥락 잊음
```

**테스트로 (짧은 피드백 루프):**
```
코드 작성 → 테스트 실행 → 실패 → 수정 → 통과
시간: 초에서 분
학습: 즉각적, 맥락 신선
```

**테스트는 올바른 방향을 유지하게 하는 피드백 메커니즘이다.**

### TFD가 완전할 때

**ROD의 각 서비스에 대해:**

- 모든 공개 메서드에 테스트 있음
- 모든 엣지 케이스 커버됨
- 모든 오류 조건 테스트됨
- 테스트가 요구사항으로 읽힘

**완전한 TFD의 징후:**

- 새 팀원이 테스트를 읽고 서비스가 뭘 하는지 이해할 수 있음
- "행복 경로"와 "불행 경로" 모두 테스트됨
- 테스트가 구현 상세에 의존하지 않음
- 테스트가 살아있는 문서 역할

---

## DGTF: Don't Go Too Fast

### 핵심 원칙

> **"Slow is smooth, smooth is fast"**

신중함은 느린 게 아니다—부드러운 것이다.
그리고 부드러움은 결국 빠르다, 재작업이 없기 때문에.

### 전제조건: "Wow" 순간

**DGTF에는 전제조건이 있다.**

DGTF의 첫 단계는 "인식"—System 1이 활성화되고 있음을 인식하는 것이다.
그런데 여기에 역설이 있다:

> System 1이 완전히 활성화되면, 자신이 System 1 상태인지 모른다.

**누가 DGTF를 사용할 수 있는가?**

"Wow" 순간을 경험하는 사람들:
```
"잠깐... 이게 맞나?"
"음, 뭔가 이상한데..."
"잠시만, 생각해보자..."
```

이 짧은 의문의 순간—이것이 "Wow"다.

**핵심 통찰:**

```
Wow 없이 → 100% System 1 → 인식 불가 → DGTF 적용 불가
Wow 있지만 DGTF 없이 → 문이 잠깐 열림 → 뭘 해야 할지 모름 → 문 닫힘
Wow + DGTF → 문이 열림 → 정확히 뭘 해야 할지 앎 → System 2 활성화
```

**그래서 DGTF는 Wow가 오기 전에 배워둬야 한다.**

Wow가 왔을 때, 무엇을 해야 하는지 바로 알아야 한다.

### LA 비유

**매니저가 팀에게 말한다: "LA로 가. 빨리."**

```
D씨: LA를 향해 바로 뛰기 시작한다.
     "빨리라고 했잖아! 지금 가야해!"
     → 가장 열심히, 가장 느린 결과

C씨: 자전거를 잡는다.
     "최소한 뭔가 하고 있긴 하지..."
     → 타협, 여전히 느림

A씨: 차를 가지러 집에 간다.
     "제대로 된 도구부터 챙기자."
     → 반대로 가는 것처럼 보이지만, 더 빠름

B씨: 비행기 스케줄을 검색한다.
     "가장 빠른 방법이 뭘까?"
     → 아무것도 안 하는 것처럼 보이지만, 가장 빠름
```

**밖에서 보면:**
- D가 가장 열심히 하는 것처럼 보임 (뛰고 있으니까!)
- A는 반대 방향으로 가는 것처럼 보임
- B는 그냥 앉아있는 것처럼 보임

**하지만 결과는 정반대다.**

**이것이 DGTF다.**

누군가 "빨리!"라고 하면:
- System 1 (D): "네!" → 뛰기 시작
- DGTF (A/B): "잠깐, 거기 가는 가장 빠른 방법이 뭐지?"

**멈춰서 생각하는 사람이 급하게 실패하는 사람을 이긴다.**

### 왜 작동하는가

DGTF는 System 1을 통제하고 System 2를 활성화한다:

```
1. 인식: "지금 서두르고 있나?"
2. 멈춤: "잠깐, 생각하자"
3. 확인: ROD 설계, TFD 테스트, 영향 분석
4. 계획: 명확한 단계
5. 실행: 신중하게, 검증하며
```

진짜 긴급상황에서도 DGTF는 적용된다.
5분 멈추는 게 아니라 5초 멈추는 것일 뿐.
그래도 여전히: 멈춤 → 생각 → 행동.

### DGTF ≠ 느림, DGTF ≠ 의지력

**흔한 오해:**
```
❌ DGTF = 천천히 일하기
❌ DGTF = 급하게 가고 싶은 충동을 참는 것
❌ DGTF = 빨리 가려는 욕구를 견디는 것
```

**진실:**
```
✅ DGTF = 신중하게 일하기
✅ DGTF = 더 힘든 게 아니라 더 효과적인 것
✅ DGTF = 재작업 회피로 에너지 절약
```

**DGTF는 의지력을 소모하지 않는다. 에너지를 절약한다.**

```
DGTF 없이:
급하게 → 버그 → 디버깅 → 수정 → 새 버그 → 더 디버깅 → 지침

DGTF로:
생각 → 올바르게 구현 → 완료 → 에너지 절약
```

**애자일 비유:**

어떤 팀들은 말한다: "이 프로젝트 쉬우니까 애자일 하자."
이건 거꾸로다. 애자일은 어려운 프로젝트에서 더 효과적이다.

**DGTF도 마찬가지다.**

```
❌ "시간 여유 있으니까 DGTF 하자"
✅ "압박 받고 있으니까 DGTF가 필요해"
```

상황이 어려울수록 DGTF가 더 도움된다.

### DGTF가 해결하지 않는 것

**DGTF는 만능이 아니다.**

**DGTF가 해결하지 않는 것:**

1. **독성적인 조직**
   - "천천히 신중하게"가 해고 사유가 되는 곳
   - 비합리적인 마감이 일상인 곳
   → 이건 환경 문제지, DGTF 문제가 아니다.

2. **비합리적인 매니저**
   - 신중한 작업이 인정받지 못하는 경우
   - "바빠 보이는 것"만 중요한 경우
   → DGTF가 다른 사람의 태도를 바꿀 수는 없다.

3. **근본적으로 망가진 시스템**
   - 완전히 재작성이 필요한 레거시 코드
   → DGTF는 예방을 위한 것이지, 치료를 위한 게 아니다.

**답:**

```
환경이 DGTF를 허용하지 않으면:
선택 1: 그 환경을 떠나라.
선택 2: 내가 통제할 수 있는 범위 안에서 DGTF를 적용하라.
```

**선택 2가 핵심이다:**

DGTF는 내면의 프로세스다.
- 타이핑 전 3초 생각하는 것—아무도 모른다.
- 코딩 전에 설계 확인하는 것—보이지 않는다.
- "빨리" 느낄 때 멈추는 것—나만 안다.

**밖에서 보면 똑같아 보인다.**
**결과만 더 좋다.**

---

## 어떻게 함께 작동하는가

```
┌─────────────────────────────────────┐
│ 설계 단계: ROD                      │
│                                     │
│ • System 2 활성                     │
│ • 완전한 서비스 체인 구축           │
│ • 헷갈리면 포함시킴                 │
│ • "Missing" 제거                    │
│                                     │
│ 결과: "무엇을 만들지" 명확          │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│ 테스트 설계 단계: TFD               │
│                                     │
│ • System 2 여전히 활성              │
│ • 각 서비스에 대한 테스트 정의      │
│ • 테스트 = 정밀한 요구사항          │
│ • 완료 기준 명확화                  │
│                                     │
│ 결과: "어떻게 검증하지" 명확        │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│ 구현 단계: DGTF                     │
│                                     │
│ • 압박 증가                         │
│ • DGTF가 System 2 유지              │
│ • ROD 설계 따름                     │
│ • TFD 테스트로 검증                 │
│                                     │
│ 결과: "어떻게 만들지" 안전          │
└─────────────────────────────────────┘
```

**시너지:**

- ROD만: 완전한 설계, 하지만 검증 메커니즘 없음
- TFD만: 검증 존재, 하지만 설계가 불완전할 수 있음
- DGTF만: 신중한 진행, 하지만 방향이나 검증 없음

- **ROD + TFD + DGTF:** 완전한 설계 + 정밀한 검증 + 신중한 실행 = 예측 가능하고, 지속 가능하며, 고품질 소프트웨어

---

## 본질: 지식이 아니라 습관

**ROD, TFD, DGTF는:**

```
❌ 원칙이 아니다
❌ 규칙이 아니다
❌ 프로세스가 아니다
❌ 지식이 아니다

✅ 사고방식이다
✅ 습관이다
✅ 훈련이다
```

### 이해 ≠ 실천

```
이해:
- 이 문서 읽음 → "알겠어"
- 고개 끄덕임 → "말이 되네"
- 전부 동의함 → "이렇게 해야지"
→ 이건 System 1이 "Got it, next!"라고 하는 것

실천:
- 내일 적용 → 어려움
- 실패 → 배움
- 다시 시도 → 조금 나아짐
- 반복 → 결국 자연스러워짐
→ 이게 훈련을 통해 습관을 만드는 것
```

DGTF를 10분 안에 이해할 수 있다.
몇 달의 연습 없이 DGTF를 실천할 수는 없다.

### 학습이 아니라 훈련

```
학습: 지식을 얻음 (일회성)
훈련: 습관을 만듦 (지속적)

운전을 잘 하려고 "배우는" 게 아니다.
운전을 잘 하려고 "훈련하는" 것이다.

DGTF를 "배우는" 게 아니다.
DGTF를 "훈련하는" 것이다.
```

### 허들을 넘는 게 끝이 아니다

```
❌ "DGTF를 한 번 성공적으로 적용했어!"
   → 끝났나? 아니다. 내일 압박이 다시 온다.

✅ "오늘 DGTF를 적용했다. 내일 또 할 거다."
   → 그리고 모레도. 그리고 다음 주도.
   → 더 이상 의식적인 노력이 아닐 때까지.
```

### 운전 비유

운전의 기본 원칙:
- 파란불이면 간다
- 브레이크를 밟으면 멈춘다
- 엑셀레이터를 밟으면 앞으로 간다

이 원칙을 안다고 좋은 운전자인가?

**아니다.**

좋은 운전자는:
- 지속적인 주의
- 상황 판단
- 다른 운전자에 대한 배려
- 이것들이 **습관**으로 몸에 배어 있음

**소프트웨어도 마찬가지다.**

SOLID, Clean Code, TDD를 안다고 좋은 개발자가 아니다.
이것들을 **습관**으로 실천할 수 있어야 좋은 개발자다.

**차이:**

```
원칙/규칙:
- "이렇게 해야 한다"
- 외부에서 강제됨
- 압박 오면 무너짐

사고방식/습관:
- "이렇게 생각한다"
- 내면에서 나옴
- 압박 와도 유지됨
```

### 가장 어려운 부분

DGTF에서 가장 어려운 건 이해하는 게 아니다.
가장 어려운 건:
- 호기심을 유지하는 것
- 의심을 계속하는 것 ("이게 정말 맞나?")
- 계속해서 연습하는 것
- 첫 성공 후에 멈추지 않는 것

**이건 기술이 아니라 태도가 필요하다.**

---

## 핵심 가치

### 1. 견고한 이론적 기반

- Kahneman (노벨상 수상자): 인간의 사고 방식
- Meadows (시스템 권위자): 시스템 작동 방식
- Altshuller (TRIZ 창시자): 문제 해결 방법

이론 + 실천 = 신뢰할 수 있는 방법론

### 2. 인간을 이해한다

인간의 약점을 인정한다:
- 압박에서 실수한다 (Kahneman)
- 부분을 보면 전체를 놓친다 (Meadows)
- 타협에 익숙하다 (Altshuller)

그리고 시스템으로 보완한다:
- ROD: 설계 단계에서 완전하게
- TFD: 피드백으로 검증
- DGTF: 신중함을 강제

### 3. 보편적으로 적용 가능

- 언어 독립 (Go, Java, Python 등)
- 도메인 독립 (Web, Mobile, Backend 등)
- 팀 규모 독립 (1인부터 대규모 팀까지)

### 4. 상호 보완적

- 각각 독립적으로 적용 가능
- 함께 적용하면 시너지
- 점진적 도입 가능

### 5. 지속 가능성

- 개인: 번아웃 방지, 전문성 향상
- 팀: 일관된 생산성, 높은 사기
- 비즈니스: 예측 가능한 배포, 경쟁 우위

---

## 시작하기

**오늘:**
1. ROD: 다음 기능 설계할 때, 먼저 서비스 체인 작성
2. TFD: 구현 전에 테스트 케이스 정의
3. DGTF: "빨리" 느낄 때 3초 멈춤

**이번 주:**
- 작은 기능 하나에 적용
- 무슨 일이 일어나는지 관찰
- 어려운 점 메모

**이번 달:**
- 여러 기능에 적용
- 동료와 공유
- 상세 방법은 실전 가이드 참조

**기억하라:**
> "좋은 프로그래머는 빠른 타이핑이 아니라 올바른 사고에서 나온다"

> "품질은 검사가 아니라 프로세스에서 만들어진다"

> "지속 가능한 개발은 방법론이 아니라 태도에서 시작한다"

**상세 구현 가이드, 예제, 체크리스트, 연습은 실전 가이드를 참조하라.**

---

**문서 버전**: 2.1  
**문서 유형**: 핵심 개념  
**대상**: 모든 개발자  
**업데이트**: 2026-01

**다음:** 구현 상세는 "DGTF++ 실전 가이드" 참조.
