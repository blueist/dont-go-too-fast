# DGTF: 느린 것이 매끄럽고, 매끄러운 것이 빠르다

## 자기 통제가 전문 개발자를 만드는 방법

---

*이 글은 압박 하에서 소프트웨어 품질을 유지하는 시리즈의 4부입니다. [3부: TFD—요구사항 = 테스트]() 읽기*

---

**솔직해집시다.**

완벽한 설계(ROD)가 있을 수 있습니다. 포괄적인 테스트(TFD)가 있을 수 있습니다. 하지만 금요일 오후 4시가 되고 매니저가 "지금 당장 이거 고쳐야 해요"라고 말하면—자신의 반응을 통제할 수 없다면 아무것도 소용없습니다.

ROD와 TFD는 **무엇**을 해야 하는지입니다.

DGTF는 모든 것이 패닉하라고 밀어붙일 때 **어떻게** 그것을 하는지입니다.

---

## 우리가 스스로에게 하는 거짓말

"DGTF는 더 많은 시간을 요청하는 것이다."
"DGTF는 더 나은 마감을 협상하는 것이다."
"DGTF는 외부 환경을 바꾸는 것이다."

**틀렸습니다.**

DGTF는 매니저, 마감, 회사 문화와 아무 상관이 없습니다.

DGTF는 **당신**에 관한 것입니다.

구체적으로, 압박이 닥칠 때 "빨리!"라고 소리치는 내면의 목소리를 통제하는 것입니다. 전역 변수를 잡는 시스템 1. 테스트를 건너뛰는 패닉.

**항상 마감을 통제할 수는 없습니다. 하지만 항상 자신의 반응을 통제할 수 있습니다.**

---

## 운전 비유

운전을 생각해보세요.

**규칙을 아는 것과 좋은 운전자인 것은 같지 않습니다.**

```
나쁜 운전자 (시스템 1):
├── 확인 없이 빠른 차선 변경
├── 공격적인 가속
├── "더 빨리 가야 해!"
├── 피드백 무시 (경적, 브레이크)
└── 결과: 사고, 스트레스, 결국 더 느림

좋은 운전자 (시스템 2):
├── 차선 변경 전 미러 확인
├── 일정한 속도
├── 교통 상황 예측
├── 피드백에 침착하게 대응
└── 결과: 안전함, 편안함, 결국 더 빠름
```

나쁜 운전자도 미러를 확인해야 한다는 것을 *압니다*. 운전 시험에 통과했습니다. 하지만 압박 하에서 그렇게 하지 않습니다.

**프로그래밍도 마찬가지입니다.**

테스트를 작성해야 한다는 것을 *압니다*. 전역 변수가 나쁘다는 것을 *압니다*. 면접에 통과했습니다.

하지만 마감 압박이 닥치면, 실제로 아는 것을 하나요?

---

## DGTF 핵심 원칙

> **"느린 것이 매끄럽고, 매끄러운 것이 빠르다."**

이것은 철학이 아닙니다. 수학입니다.

```
서두르는 개발자:
├── 1일차: 빠른 코딩 (3시간, 테스트 없음)
├── 2일차: 버그 등장 (2시간 디버깅)
├── 3일차: 수정이 새 버그 생성 (2시간)
├── 4일차: 일부 재작성 (4시간)
├── 5일차: 드디어 안정 (1시간 정리)
└── 합계: 12시간, 취약한 코드

DGTF 개발자:
├── 1일차: 설계 확인, 신중하게 작성 (4시간)
├── 2일차: 테스트 통과, 통합 작동 (3시간)
└── 합계: 7시간, 견고한 코드
```

DGTF 개발자는 설계를 확인하고 신중한 데 시간을 "낭비"했습니다.

서두르는 개발자는 그 단계들을 건너뛰어 시간을 "절약"했습니다.

**누가 실제로 더 빨리 끝냈나요?**

---

## 5단계 워크플로우

압박이 닥치면, 이 순서를 따르세요:

### 1단계: 인식

*"지금 서두르고 있나?"*

신체 신호:
- 심장 박동 증가
- 얕은 호흡
- 긴장된 어깨
- 땀

정신 신호:
- "빨리" 생각이 반복됨
- 터널 시야 (당장의 문제만 보임)
- 대안을 생각할 수 없음
- 짜증

이 중 하나라도 느끼면: **시스템 1이 활성화되고 있습니다.**

### 2단계: 멈춤

*"멈추자."*

말 그대로:
- 키보드에서 손을 뗌
- 세 번 깊게 숨쉼
- 다섯까지 셈
- 스스로 묻기: "왜 서두르고 있지?"

이 멈춤이 시스템 1 사이클을 끊습니다. 10초뿐이지만, 시스템 2를 위한 공간을 만듭니다.

### 3단계: 확인

*"내 설계가 뭐라고 하지?"*

- ROD 서비스 체인 열기
- TFD 테스트 케이스 열기
- 묻기: "어떤 서비스를 구현하고 있지?"
- 묻기: "이 서비스가 무엇을 해야 하지?"
- 묻기: "끝나면 어떤 테스트가 통과해야 하지?"

설계 문서가 닻입니다. 생각할 시간이 있을 때 작성되었습니다. 신뢰하세요.

### 4단계: 계획

*"다음 작은 단계가 뭐지?"*

한 번에 모든 것을 해결하려 하지 마세요. 하나를 고르세요:
- "이 하나의 서비스를 구현하겠다"
- "이 하나의 테스트를 통과시키겠다"
- "이 하나의 오류 케이스를 처리하겠다"

작은 단계는 시스템 2 친화적입니다. 큰 도약은 시스템 1을 트리거합니다.

### 5단계: 실행

*"신중하게 하자."*

- 코드를 천천히 작성
- 즉시 테스트 실행
- 결과 확인
- 뭔가 잘못되면 2단계로 돌아감

이 사이클—인식, 멈춤, 확인, 계획, 실행—은 압박 하에서도 시스템 2를 활성 상태로 유지합니다.

---

## 금요일 오후 시나리오

DGTF를 실제로 봅시다.

**상황:**
금요일 오후 4시. 매니저: "결제 처리에 버그가 있어요. 퇴근 전에 고쳐주세요."

**시스템 1 반응:**
```
1. 즉시 코드 열기
2. 관련되어 보이는 것 찾기
3. 변경
4. "내 컴퓨터에서는 되는데!"
5. 운영에 푸시
6. 퇴근
7. (월요일: 세 개의 새 버그)
```

**DGTF 반응:**
```
1. 인식: 심장 박동 증가. "압박을 느끼고 있어."

2. 멈춤: 키보드에서 손을 뗌. 깊게 숨쉼.
   "왜 서두르고 있지? 매니저 반응이 두려워서."

3. 확인:
   - 결제 시스템 ROD 설계 열기
   - 어떤 서비스가 실패하고 있지?
   - 그 서비스의 TFD 테스트 열기
   - 이 버그를 잡는 테스트가 있나?
   - (테스트가 없다면, 그게 첫 번째 문제)

4. 계획:
   - "먼저 테스트로 버그를 재현하겠다"
   - "그 다음 코드를 고치겠다"
   - "그 다음 관련 테스트가 여전히 통과하는지 확인하겠다"

5. 실행:
   - 실패하는 테스트 작성 (10분)
   - 코드 수정 (15분)
   - 모든 관련 테스트 실행 (5분)
   - 모두 통과
   - 확신을 갖고 커밋

6. 합계: 30분, 견고한 수정
   vs
   시스템 1: 지금 10분 + 월요일 3시간
```

---

## 자기 통제가 전문가를 만든다

대부분의 사람들이 놓치는 부분입니다:

**DGTF는 느리게 하는 것이 아닙니다. 신뢰를 얻는 것입니다.**

```
DGTF 없는 개발자 (3개월 후):
├── 것을 망가뜨리는 빠른 수정
├── 매니저: "또 당신 버그야?"
├── 신뢰 감소
├── 더 많은 감독
├── 더 많은 압박
├── 더 나쁜 결정
└── 악순환

DGTF 개발자 (3개월 후):
├── 작동하는 신중한 수정
├── 매니저: "믿을 수 있어"
├── 신뢰 증가
├── 더 많은 자율성
├── 더 적은 압박
├── 더 나은 결정
└── 선순환
```

**전문가는 결과를 통해 신뢰를 얻습니다.** 영웅적 노력이나 긴 시간이 아니라, 일관되고 믿을 수 있는 배포를 통해.

압박 하에서도 것을 망가뜨리지 않고 처리할 수 있다는 것을 증명하면, 매니저가 맴돌기를 멈춥니다. 마감이 협상 가능해집니다. 처음부터 필요했던 그 여유를 얻게 됩니다.

**자기 통제는 자기 통제가 더 쉬워지는 환경을 만듭니다.**

---

## 진짜 긴급 상황은 어떻게?

"하지만 진짜 급할 때도 있잖아요!"

맞습니다. 운영이 다운됐습니다. 고객이 돈을 잃고 있습니다. 매 분이 중요합니다.

**그때도 DGTF가 적용됩니다.**

```
진짜 긴급상황 DGTF:

1. 인식: "이건 급하다고 느끼는 게 아니라 
   실제로 급한 거다"

2. 멈춤: 5분이 아니라 5초
   "실제 문제가 뭐지?"

3. 확인:
   - 오류 메시지가 뭐지?
   - 최근에 뭐가 바뀌었지?
   - 영향 범위가 어디까지지?

4. 계획:
   - "먼저 롤백, 그 다음 조사"
   - 또는 "이 특정 것만 핫픽스"
   - "될 때까지 아무거나 바꾸기"가 아님

5. 실행:
   - 하나의 변경만 함
   - 도움이 됐는지 확인
   - 필요하면 반복
```

차이는 속도가 아닙니다—**의도성**입니다. 긴급 상황에서도 패닉 반응이 아니라 의식적인 결정을 내리고 있습니다.

---

## 클린 코더와의 연결

로버트 마틴의 *클린 코더*는 말합니다:

> "필요할 때 아니라고 말해라. 전문가가 되어라."

좋은 조언입니다. 하지만 **어떻게**?

DGTF가 그 방법입니다.

```
클린 코더가 말하는 것:
"압박에 굴복하지 마라"
"품질을 유지하라"
"전문가가 되어라"

DGTF가 말하는 것:
"압박을 인식하는 방법 (1단계)"
"멈추는 방법 (2단계)"
"품질을 유지하는 방법 (3-5단계)"
"실제로 하는 방법"
```

---

## 일상 실천

DGTF는 긴급 상황만을 위한 것이 아닙니다. 매일 습관을 만드세요:

### 아침 점검
코딩 전에:
- [ ] 오늘의 작업이 명확한가?
- [ ] 설계가 있는가?
- [ ] 테스트가 있는가?
- [ ] 첫 작은 단계가 뭔가?

### 매 25분마다 (뽀모도로)
작업 중에:
- [ ] 설계를 따르고 있나?
- [ ] 서두르고 있나?
- [ ] 테스트를 실행했나?
- [ ] 도움이 필요한가?

### 커밋 전에
푸시 전에:
- [ ] 모든 테스트가 통과하나?
- [ ] 코드 리뷰 (셀프)?
- [ ] 코너를 잘랐나?
- [ ] 확신이 있나?

### 저녁 회고
퇴근 후:
- [ ] 오늘 언제 압박을 느꼈나?
- [ ] 어떻게 반응했나?
- [ ] 다르게 했을 것은?

---

## 역설의 해결

1편의 모순을 기억하세요:

```
"빠른 개발" vs "높은 품질"

전통적 타협:
빠름 → 낮은 품질
높은 품질 → 느림

TRIZ 해결 (시간에 의한 분리):
설계 단계 → 느리고, 신중하고, 완전하게
구현 단계 → 빠르고, 안내받고, 검증됨

결과: 빠르면서 높은 품질
```

**DGTF는 이것을 작동하게 하는 규율입니다.**

DGTF 없이는, 훌륭한 설계가 있어도 구현 중에 패닉할 수 있습니다. 포괄적인 테스트가 있어도 서두를 때 건너뛸 수 있습니다.

DGTF는 신중하게 준비한 시스템 2 작업이 시스템 1이 장악하려 할 때 실제로 사용되도록 보장합니다.

---

## 다음: 통합

세 가지 방법론을 다뤘습니다:
- **ROD**: 무엇을 만들지 (완전한 설계)
- **TFD**: 어떻게 검증할지 (테스트가 요구사항)
- **DGTF**: 어떻게 침착하게 할지 (압박 하의 시스템 2)

**마지막 글**에서는 완전한 예시를 통해 어떻게 함께 작동하는지 보여드립니다—설계부터 배포까지 이커머스 장바구니 만들기.

보게 될 것:
- 전체 ROD 서비스 체인
- 완전한 TFD 테스트 스위트
- 구현 중 적용되는 DGTF
- 결과: 작동하는 코드, 제시간에, 드라마 없이

---

*DGTF는 느리게 하는 것이 아닙니다. 의도적으로 하는 것입니다. 생각하기 위해 멈추는 개발자가 실패하기 위해 서두르는 개발자를 이깁니다.*

**다음: 모든 것을 합치기 →**

---

*당신의 트리거는 무엇인가요? 알면서도 서두르게 만드는 것? 댓글에서 공유해주세요—인식하는 것이 첫 단계입니다.*
