# Can I Just Escape from a Dirty Pond? : When Fear Rules Your Codebase

## 인간의 역량을 넘어선 코드를 다시 인간의 손으로

---

![image](https://i.ibb.co/xK0LTn91/08.png)

*이 글은 "압박 속에서 품질을 유지하는 소프트웨어 개발 철학" 시리즈의 여덟 번째입니다.*

*이것은 개선(Improvement)이 아니다. 생존을 위한 복구(Restoration)다.*

---

**"그 부분은 건드리지 마세요."**

이 말을 들어본 적 있는가?

"지금은 잘 돌아가고 있으니까요."
"왜 그렇게 동작하는지는 몰라요. 그냥 돌아가요."
"원래 만든 사람은 퇴사했어요."

---

이것은 단순한 조언이 아니다.

**고백이다.**

이 코드는 이미 인간의 역량을 넘어섰다.
아무도 이해하지 못한다.
아무도 예측하지 못한다.
아무도 통제하지 못한다.

우리는 이것을 **'더러운 연못(Dirty Pond)'**이라 부른다.

---

## "그냥" 탈출할 수 있을까?

많은 개발자가 묻는다.

"Can I **just** escape from a dirty pond?"

**그냥.** 큰 노력 없이. 쉽게. 빠르게.

---

흔한 핑계들:

"시간만 있으면 고칠 텐데."
"나중에 리팩토링할 거예요."
"다음 스프린트에서 할게요."

---

진실은 냉정하다.

**기술과 습관이 없다면, 시간이 있어도 못 고친다.**

시간이 주어져도 당신은:
- 어디서 시작할지 모른다
- 무엇을 테스트할지 모른다
- 어떻게 격리할지 모른다
- 두려움에 압도된다

---

## Part 1: 공포의 메커니즘

### 두려움이라는 신호

Dirty Pond를 어떻게 알 수 있는가?

**두려움이다.**

```
코드를 볼 때:
    "이거 건드려도 될까?"
    "내가 이해할 수 있을까?"
    "실수하면 어떡하지?"

배포할 때:
    "금요일엔 배포 안 해"
    "롤백 준비됐어?"

휴가 갈 때:
    "내가 없으면 어떡하지?"
```

두려움은 본능적 경고다.
"이건 네 역량을 넘어섰어."

두려움이 있다면, 당신은 Dirty Pond에 있는 것이다.

---

### 공포가 이성을 마비시키는 방법

문제는 두려움 자체가 아니다.
**두려움이 우리의 판단을 어떻게 왜곡하는가**가 문제다.

---

Dirty Pond는 개발자를 특별한 상태에 가둔다.

**영원한 금요일 오후 4시.**

---

금요일 오후 4시를 상상하라.

배포가 1시간 남았다.
버그가 발견됐다.
심장이 뛴다.
손이 떨린다.

이 순간, 뇌에서 일어나는 일:

```
System 1 (본능):
    → "빨리 고쳐! 아무거나!"
    → "일단 동작하게만 해!"
    → "생각은 나중에!"

System 2 (이성):
    → ... (마비됨)
```

**공포는 System 2를 꺼버린다.**

---

Dirty Pond는 **365일** 이 상태다.

코드 한 줄을 고칠 때마다 금요일 오후 4시.
테스트를 돌릴 때마다 금요일 오후 4시.
배포할 때마다 금요일 오후 4시.

만성적 압박.
만성적 공포.
만성적 System 1.

---

### 기술적 부채의 고착화

이것이 기술적 부채가 쌓이는 진짜 이유다.

```
공포 → System 1 지배
    → "일단 돌아가게" 코드 작성
    → 더 복잡해짐
    → 더 큰 공포
    → 더 강한 System 1 지배
    → ...
```

**악순환.**

공포가 부채를 만들고,
부채가 공포를 키운다.

---

### 지식 vs 습관

이 악순환 속에서 무엇이 살아남는가?

**지식은 증발한다.**

```
Clean Code?
SOLID?
디자인 패턴?

→ 압박이 오면 사라진다
→ System 2와 함께 꺼진다
```

**습관은 살아남는다.**

```
DGTF로 멈추는 습관
테스트 먼저 짜는 습관
작게 커밋하는 습관

→ System 1에서도 작동한다
→ 몸에 배어 있기 때문이다
```

---

**"지식은 압박 속에서 나를 배신하지만, 습관은 나를 구원한다."**

우리는 뇌를 고치는 것이 아니다.
**손의 습관을 고치는 것이다.**

System 1을 없앨 수는 없다.
하지만 System 1조차 따르는 습관을 만들 수 있다.

---

## 문지기의 질문

수술실로 들어가기 전, 한 가지 질문이 있다.

Gerald Weinberg.
소프트웨어 공학의 선구자.
그의 책 "Are Your Lights On?"에서 묻는다.

**"I have a solution. But do you really want it?"**

---

고칠 수 있다. 방법은 있다.

하지만 당신은 **정말로** 원하는가?

---

**수리의 비용:**

```
- 테스트를 짜야 한다
- 설계를 다시 봐야 한다
- 천천히 가야 한다
- 불편함을 감수해야 한다
```

"나중에 할게요"는 거부의 다른 표현이다.

정말로 원하는 사람만 이 문을 통과할 수 있다.

---

## Part 2: 수술의 과정

의지가 확인되었다면, 이제 수술을 시작한다.

목표는 명확하다.

**Beyond Human → Within Human**

코드를 다시 인간의 역량 안으로 가져온다.
이해 가능하게.
예측 가능하게.
통제 가능하게.

---

*이 파트에서는 수술의 개요를 다룬다.*
*구체적인 기법과 실전 테크닉은 다음 시리즈 **"FBS: Fix Broken Software"**에서 깊이 있게 다룰 예정이다.*

---

### Step 1: 문제의 객관화

**"I Wanna DO fix, but I cannot touch it."**

고치고 싶다. 하지만 건드릴 수 없다.

이것이 수리의 시작점이다.

---

**왜 건드릴 수 없는가?**

WHI (What Happens If I touch it?):

```
"뭔가 깨질 거야."
"정확히 뭐가?"
"...모르겠어."
```

**왜 고쳐야 하는가?**

WHI (What Happens If I don't touch it?):

```
"계속 두려움 속에 산다."
"같은 버그가 반복된다."
"연못은 점점 더러워진다."
```

---

진짜 문제가 보인다.

문제는 코드가 아니다.
**"내가 모른다"가 문제다.**

---

**오해하지 마라.**

"모른다"는 당신의 무능력이 아니다.

시스템이 당신을 모르게 만든 것이다.

```
문서 없음
테스트 없음
만든 사람 없음
지층처럼 쌓인 코드
```

시스템이 정보를 은닉하고, 당신을 거부하고 있다.
당신의 실력 문제가 아니다.

---

하지만 결과는 같다.

모르기 때문에 두렵다.
두렵기 때문에 건드리지 않는다.
건드리지 않기 때문에 계속 모른다.

이 순환을 끊는 것이 수리의 시작이다.

---

### Step 2: ROD - 숨겨진 Service Chain 발굴

인간의 역량을 넘어선 복잡성.
어떻게 다시 역량 안으로 가져오는가?

**엉킨 코드 속에서 Service Chain을 발견한다.**

수천 줄의 스파게티 코드.
그 속에서 데이터가 이동하는 단 하나의 경로를 찾아내는 작업.
이것이 망가진 시스템 수리에서의 ROD다.

레거시 코드는 지층(Strata)과 같다.

```
3년 전의 기획.
1년 전의 급박한 버그 수정.
어제 들어온 무리한 요구사항.

겹겹이 쌓여 있다.
```

하지만 그 지층 속에도 흐름이 있다.
당시 제작자가 의도했던(혹은 누락했던) 본래의 책임이 있다.

---

**달리는 열차의 부품 교체.**

망가진 시스템 수리는 멈출 수 없는 시스템을 다룬다.

```
열차는 달리고 있다 (서비스 운영 중)
승객은 타고 있다 (사용자 있음)
멈출 수 없다 (다운타임 불가)

하지만 부품은 낡았다 (레거시)
교체해야 한다 (수리)
```

모든 부품을 한 번에 바꿀 수 없다.
**핵심 부품(Service Chain)을 찾아 하나씩 교체한다.**

```
새 코드에서 ROD:
    → 설계도를 그린다
    → 처음부터 Chain을 만든다

망가진 시스템 수리에서 ROD:
    → 달리는 열차에서
    → 핵심 부품(Chain)을 식별하고
    → 하나씩 교체한다
```

**이것은 정밀한 작업이다.**

```
1. 레거시 코드 분석
   → 지층 속 실제 흐름 추적

2. Service Chain 추출
   → "이 코드가 실제로 하는 일이 뭐지?"
   → 핵심 책임의 연결 고리만 찾아냄

3. 격벽(Interface) 세우기
   → Chain을 기준으로 경계 설정
   → 낡은 부품을 인터페이스 뒤로 격리
   → 새 부품이 들어갈 자리 확보
```

Chain이 보이면, 교체 가능성(Replaceability)이 열린다.

---

### Step 3: TFD - 안전 지지대

TFD에서 테스트는 요구사항이다.

레거시에서 요구사항은 무엇인가?

**"현재 동작 그대로."**

바꾸면 안 된다.
사용자는 지금 동작하는 대로 기대한다.
그것이 요구사항이다.

따라서 현재 동작을 기록하는 테스트가 필요하다.

**Pinning Test.**

Michael Feathers가 그의 책 "Working Effectively with Legacy Code"에서 소개한 기법이다.
레거시 코드를 다루는 개발자라면 반드시 읽어야 할 책이다.

```
코드를 고치기 전:
    현재 입출력을 그대로 기록
    "지금 이렇게 동작한다" = 요구사항
    
코드를 고친 후:
    테스트가 통과하면 → 요구사항 유지됨
    테스트가 실패하면 → 요구사항 깨짐
```

---

**"테스트 짜는 것도 무서운데요?"**

완벽한 단위 테스트를 말하는 게 아니다.

```
입력값 넣고
결과값 로그로 찍어보는 수준.
이것도 Pinning Test다.
```

**조잡한 말뚝이라도 괜찮다.**

말뚝 없이 건드리는 것보다
조잡한 말뚝이라도 있는 게 낫다.

SNP를 기억하라.
완벽한 테스트 없음 < 조잡한 테스트 하나 < 더 나은 테스트.
작은 걸음도 가치 있다.

---

Pinning Test는 심리적 안전망이다.
영원한 금요일 오후 4시에 당신의 유일한 아군이다.

---

**Chain을 발굴(ROD)하고 말뚝을 박는(Pinning) 순간,**
**코드는 더 이상 '알 수 없는 괴물'이 아니다.**

내 머릿속에 들어오는 '유한한 책임의 단위'가 된다.
이때 비로소 코드는 인간의 통제권 안으로 복귀한다.

---

### Step 4: DGTF + SNP - 안전한 보폭

압박이 심할수록 더 천천히 간다.

하지만 "천천히"는 추상적이다.
**구체적인 보폭**이 필요하다.

---

**DGTF의 리듬:**

```
수정 전:
    10초간 멈춤
    "내가 지금 맞게 가고 있나?"
    
수정 후:
    테스트 실행
    "내가 뭔가 깨뜨렸나?"
```

서두르는 System 1을 막는다.

---

**SNP의 보폭:**

한 번에 함수를 고치지 마라.
**변수명 하나를 바꾸고 테스트를 돌려라.**

```
Step 1: 변수명 변경 → 테스트 → 커밋
Step 2: 함수 추출 → 테스트 → 커밋
Step 3: 인터페이스 삽입 → 테스트 → 커밋
...
```

**되돌리기 규칙:**

```
테스트가 깨지면?
    → 고민하지 마라
    → 즉시 revert
    → 더 작게 쪼개서 다시 시작
```

고민하는 순간 System 1이 개입한다.
"에이, 이 정도는 괜찮겠지..."
**안 괜찮다.**

---

이것이 달리는 열차에서 부품을 교체하는 방법이다.

```
작게 쪼갠다
테스트한다
커밋한다
깨지면 되돌린다
더 작게 쪼갠다
```

어제보다 1% 더 맑아진 연못.
**이미 정화가 시작된 것이다.**

---

## 탈출의 진짜 의미

진정한 탈출은 무엇인가?

**장소를 옮기는 것이 아니다.**

```
"새로 만들자" → 같은 연못을 또 만든다
"다른 회사 가자" → 거기도 연못이 있다
```

**역량을 갖추는 것이다.**

```
- 코드의 책임을 명확히 하는 기술
- 테스트로 보호하는 기술
- 교체 가능하게 만드는 기술
- 압박 속에서도 작동하는 습관
```

역량이 있으면 어떤 연못이든 정화할 수 있다.

---

## 맑은 물 한 바가지

연못 전체를 한 번에 정화할 수는 없다.

하지만 오늘 맑은 물 한 바가지를 부을 수 있다.

```
오늘 만든 Pinning Test 하나.
오늘 분리한 책임 하나.
오늘 세운 격벽 하나.
```

오늘 당신이 부은 맑은 물 한 바가지는
내일의 **교체 가능성(Replaceability)**을 위한 초석이다.

연못 전체를 비울 수는 없어도,
특정 Chain 하나를 인터페이스로 격리하는 데 성공했다면
당신은 그 부분에 한해서는 연못에서 탈출한 것이다.

이것이 쌓이면 연못은 맑아진다.

---

**당신은 정말로 탈출하길 원하는가?**

원한다면, 오늘 시작하라.

맑은 물 한 바가지부터.

---

*Don't Go Too Fast.*

*허들을 넘는 것이 끝이 아니다.*
*허들을 넘지 못해도 끝이 아니다.*
*우리는 길 위에 있다.*

---

*이 글은 "압박 속에서 품질을 유지하는 소프트웨어 개발 철학" 시리즈의 여덟 번째입니다.*

---

**시리즈:**
1. [좋은 개발자가 압박 속에서 나쁜 결정을 내리는 이유]()
2. [ROD: 설계 완전, 구현 빠르게]()
3. [TFD: 요구사항 = 테스트]()
4. [DGTF: 느린 것이 매끄럽고, 매끄러운 것이 빠르다]()
5. [모두 합치기]()
6. [Replaceability: 좋은 소프트웨어의 궁극적 목표]()
7. [SNP: 작은 걸음도 가치 있다]()
8. **Can I Just Escape from a Dirty Pond? : When Fear Rules Your Codebase** ← 지금 여기

**다음 시리즈:**
- FBS: Fix Broken Software (예정)

---

*Connect with me:*
- *GitHub: [dont-go-too-fast](https://github.com/bakmeon/dont-go-too-fast)*
- *Email: stillblueist@naver.com*
