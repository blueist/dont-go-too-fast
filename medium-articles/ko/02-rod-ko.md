# ROD: 완전하게 설계하고, 빠르게 구현한다

## "빠지는 것보다 많은 것이 낫다"가 프로젝트를 살리는 이유

---

*이 글은 압박 하에서 소프트웨어 품질을 유지하는 시리즈의 2부입니다. [1부: 왜 좋은 개발자가 압박 속에서 나쁜 결정을 내리는가]() 읽기*

---

**이 시나리오를 상상해보세요:**

로그인 기능을 구현하고 있습니다. 두 개의 서비스를 설계했습니다:
1. `ValidateCredentials(username, password)`
2. `CreateSession(user)`

코딩을 시작합니다. `CreateSession`에 도달할 때까지 모든 것이 순조롭습니다.

*잠깐... `user`는 어디서 오는 거지?*

설계서에 없습니다. 사용자를 찾는 서비스가 없습니다. 비밀번호를 검증하는 서비스가 없습니다.

**"빠진 것(Missing)"을 발견했습니다.**

그리고 지금은 금요일 오후 4시입니다.

심장 박동이 빨라집니다. 시스템 1이 활성화됩니다. 그리고 스트레스 받는 모든 개발자가 하는 일을 합니다:

```go
// 빠른 수정 - 나중에 정리하지 뭐
var globalUserCache = make(map[string]*User)
```

기술 부채는 이렇게 태어납니다. 게으름이나 무지 때문이 아니라—**불완전한 설계가 마감 압박을 만나서**.

---

## 핵심 원칙: 빠지는 것보다 많은 것이 낫다

ROD(책임 지향 설계)는 하나의 간단한 아이디어에 기반합니다:

> **불필요한 것을 제거하는 것이 빠진 것을 추가하는 것보다 쉽다.**

왜일까요? 압박 하에서 우리 뇌가 작동하는 방식 때문입니다.

**구현 중 제거하기:**
- 시스템 2: "이 서비스는 필요 없구나. 삭제하자."
- 행동: Delete 키 누르기
- 위험: 낮음 (코드가 존재한 적이 없음)

**구현 중 추가하기:**
- 시스템 1: "설계에 없는 게 필요해!"
- 패닉: "이걸 어떻게 만들지?"
- 반응: 전역 변수 / 싱글톤 / 하드코딩
- 위험: 높음 (급한 결정이 부채를 만듦)

"필요한 것보다 많이" 설계하면, 안전하게 제거할 것들이 생깁니다. "딱 맞게만" 설계하면, 어떤 빈틈도 패닉을 유발합니다.

---

## 서비스 체인이란?

서비스 체인은 작업을 완료하는 데 필요한 모든 단계의 완전한 지도입니다.

로그인 기능을 제대로 다시 설계해봅시다:

```
로그인 서비스 체인 (완전한 버전)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. ValidateCredentialsFormat(username, password)
   → 입력 형식 검증
   → 반환: error 또는 nil

2. FindUserByUsername(username)
   → 데이터베이스에서 사용자 조회
   → 반환: *User 또는 ErrUserNotFound

3. VerifyPassword(inputPassword, user.HashedPassword)
   → 비밀번호를 안전하게 비교
   → 반환: bool, error

4. CheckAccountStatus(user)
   → 계정이 잠기거나 비활성화되지 않았는지 확인
   → 반환: error 또는 nil

5. CreateSession(user)
   → 새 세션 객체 생성
   → 반환: *Session

6. StoreSession(session)
   → 세션을 저장소에 영속화
   → 반환: error 또는 nil

7. GenerateSessionToken(session)
   → JWT 또는 세션 토큰 생성
   → 반환: string, error

8. LogLoginEvent(user, timestamp)
   → 감사를 위해 로그인 기록
   → 반환: error 또는 nil
```

**무슨 일이 일어났는지 주목하세요:**

원래 2개 서비스 설계에는 6개의 빠진 조각이 있었습니다. 그것은 구현 중에 시스템 1이 나쁜 결정을 내릴 6번의 기회입니다.

완전한 8개 서비스 체인에는 빈틈이 없습니다. 구현은 *발명*이 아니라 *따르기*가 됩니다.

---

## 생성자 금지, 정적 필드 금지 규칙

처음에는 이상하게 보이는 규칙이 있습니다:

> **서비스 설계에서 생성자나 정적 필드를 절대 사용하지 마라.**

왜일까요? 그것들은 시스템 1의 탈출구이기 때문입니다.

**생성자가 허용될 때:**
```go
// 시스템 1: "사용자가 필요해!"
user := new(User)  // 서비스 필요 없음!
user.Name = "admin"  // 검증 없음!
// 문제가 숨겨짐. 부채가 생성됨.
```

**생성자 없이:**
```go
// 시스템 2: "사용자가 필요한데... 어떻게 얻지?"
// → 설계 확인
// → 이것을 위한 서비스가 없네!
// → 빠진 것 발견
// → 지금 설계를 고침, 나중에 운영에서가 아니라
```

제약은 생각하게 강제합니다: *"이 객체는 어디서 오는가?"*

답이 서비스 체인에 없다면, 빠진 것을 찾은 것입니다. 금요일 오후 위기 때보다 설계 중에 찾는 것이 낫습니다.

---

## 실제 예시: 결제 시스템

좀 더 복잡한 것에 ROD를 적용해봅시다.

**나쁜 설계 (숨겨진 빈틈이 있는 6개 서비스):**
```
1. ValidatePayment
2. ProcessPayment
3. SendConfirmation
4. UpdateInventory
5. CreateOrder
6. LogTransaction
```

합리적으로 보입니다. 하지만 구현 중에:
- 결제 수단 검증은 어디서 일어나지?
- 누가 카드 데이터를 암호화하지?
- 결제 게이트웨이 응답은?
- 부분 실패를 어떻게 처리하지?

**완전한 ROD 설계 (빈틈 없는 18개 서비스):**

```
결제 시스템 서비스 체인
━━━━━━━━━━━━━━━━━━━━━━━━━━━━

입력 검증 서브시스템:
1. ValidatePaymentRequest
2. FindUserAccount  
3. CheckUserPaymentEligibility

계산 서브시스템:
4. CalculateTotalAmount
5. CheckInventoryAvailability

예약 서브시스템:
6. ReserveInventory

결제 처리 서브시스템:
7. ValidatePaymentMethod
8. CreatePaymentTransaction
9. EncryptPaymentData
10. CallPaymentGateway
11. DecryptPaymentResponse
12. ValidatePaymentResponse

상태 관리 서브시스템:
13. UpdateTransactionStatus
14. ConfirmInventoryReservation

출력 서브시스템:
15. CreateOrderRecord
16. SendPaymentConfirmation
17. UpdateUserPaymentHistory

모니터링 서브시스템:
18. LogPaymentEvent
```

**네, 더 깁니다. 그게 포인트입니다.**

모든 서비스가 명확하고 단일한 책임을 가집니다. 모든 빈틈이 채워졌습니다. 서비스 #10(`CallPaymentGateway`)을 구현할 때, 정확히 그 전에 무엇이 오고(#9: 암호화된 데이터) 그 후에 무엇이 오는지(#11: 응답 복호화) 압니다.

놀라움 없음. 패닉 없음. 전역 변수 없음.

---

## SOLID와의 연결

이렇게 생각할 수 있습니다: "이거 클린 아키텍처 같은데."

맞습니다. ROD는 혁명적인 새 기술이 아닙니다. 이미 알고 있는 원칙을 **왜**, **언제**, **어떻게** 적용하는지에 대한 답입니다.

| SOLID 원칙 | ROD 적용 |
|------------|----------|
| **S**ingle Responsibility | 각 서비스 = 하나의 일 |
| **O**pen-Closed | 서비스 추가, 기존 것 수정 안 함 |
| **L**iskov Substitution | 서비스는 인터페이스로 교체 가능 |
| **I**nterface Segregation | 서비스당 최소한의 인터페이스 |
| **D**ependency Inversion | 구현이 아닌 인터페이스에 의존 |

차이는 타이밍입니다:

```
전통적 접근:
구현 → 문제 발견 → SOLID 적용 → 리팩토링

ROD 접근:
SOLID로 설계 → 구현 → 리팩토링 불필요
```

ROD는 사고를 있어야 할 곳에 둡니다: **설계 단계**에서, 시스템 2가 활성화되어 있고 제대로 생각할 시간이 있을 때.

---

## 오버엔지니어링 아닌가요?

"이거 과도하게 설계된 시스템을 만드는 것 아닌가요?"

아닙니다. 이유는 이렇습니다:

**오버엔지니어링**은 불필요한 기능을 *구현*하는 것입니다.

**ROD**는 완전한 서비스를 *정의*하는 것—그리고 필요한 것만 구현하는 것입니다.

```
ROD 설계 단계 (1시간):
- 20개 서비스 정의
- 전체 시스템 이해
- 모든 관계 파악

구현 단계:
- 15개 서비스 구현
- 5개는 "아직 필요 없음"으로 제거
- 급한 추측이 아닌 정보에 기반한 결정
```

정의한 서비스를 제거하는 것은 사소합니다. 놓친 서비스를 추가하는 것이 재앙이 일어나는 곳입니다.

---

## ROD 체크리스트

구현을 시작하기 전에 확인하세요:

**완전성:**
- [ ] 이 서비스들만으로 요구사항을 달성할 수 있는가?
- [ ] 모든 객체에 그것을 생성하는 서비스가 있는가?
- [ ] 모든 검증에 전용 서비스가 있는가?
- [ ] 모든 외부 호출에 서비스가 있는가?

**지름길 없음:**
- [ ] 생성자를 직접 사용하지 않는가?
- [ ] 정적 필드를 사용하지 않는가?
- [ ] "당연한" 단계에 대한 가정이 없는가?

**SOLID 적용:**
- [ ] 각 서비스가 하나의 책임을 가지는가?
- [ ] 서비스들이 인터페이스를 통해 소통하는가?
- [ ] 의존성이 주입 가능한가?

체크되지 않은 항목이 있으면, 여러분을 매복 공격할 빠진 것이 있는 것입니다.

---

## 지금 해볼 것

현재 작업 중인 기능을 가져와보세요. 스스로에게 물어보세요:

1. 완료하는 데 필요한 **모든 서비스 나열**
2. **각 객체에 대해** 묻기: "이것은 어디서 오는가?"
3. **각 단계에 대해** 묻기: "여기서 무엇이 잘못될 수 있는가?"
4. 빠진 것에 대해 **서비스 추가**

목록이 길어 보여도 걱정하지 마세요. 길이가 적이 아닙니다—빈틈이 적입니다.

---

## 다음: TFD

ROD는 "무엇을 만들어야 하는가?"에 답합니다.

하지만 언제 완료되는지 어떻게 알까요? 실수를 일찍 어떻게 잡을까요? 시스템 1이 장악하기 전에 충분히 빠른 피드백을 어떻게 얻을까요?

**다음 글**에서는 TFD(테스트 우선 개발)를 소개합니다—요구사항을 테스트로 취급하는 것이 ROD를 작동하게 하는 피드백 루프를 만드는 방법.

배울 내용:
- "요구사항 = 테스트"가 왜 모든 것을 바꾸는지
- TFD가 TDD를 어렵게가 아니라 쉽게 만드는 방법
- 시스템 1 실수를 잡는 피드백 루프 만들기
- 운영 시스템의 실제 테스트 시나리오

---

*ROD는 더 많은 코드를 작성하는 것이 아닙니다. 정확히 어떤 코드를 작성해야 하는지 아는 것입니다—압박이 결정을 내리기 전에.*

**다음: TFD—요구사항 = 테스트 →**

---

*구현 중에 발견한 최악의 "빠진 것"은 무엇인가요? 댓글에서 공유해주세요.*
