# Replaceability: 좋은 소프트웨어의 궁극적 목표

---

개발자가 파일을 복사한다.
붙여넣는다.
조금 수정한다.
작동한다.
퇴근한다.

다음 날, 또 복사한다.
붙여넣는다.
작동한다.

이게 뭐가 잘못됐나?

---

우리는 들어왔다. Low Coupling이 좋다고. Design Pattern을 쓰라고. SOLID 원칙을 지키라고.

하지만 솔직히 말해보자.

"좋다고 들었다. 근데 이게 내 시스템에 뭘 좋게 해주는지 모르겠다."

그래서 복붙한다. 지금 되니까. 빠르니까. 잘 돌아가는 것 건드리기 싫으니까.

이게 대부분 개발자의 현실이다. 그리고 그들이 틀린 것도 아니다.

---

## 진짜 문제

Low Coupling. 좋다고 들었다.

"결합도가 낮으면 유지보수가 쉬워진다."

맞는 말 같다. 근데 지금 내가 만드는 주문 API, 이게 Low Coupling인지 아닌지 모르겠다. 그리고 Low Coupling이면 다음 달 유지보수할 때 뭐가 어떻게 달라지는지 상상이 안 된다.

좋다고 들었다. 근데 내 현재 코드와 연결이 안 된다.

---

Design Pattern. 좋다고 들었다.

"Factory Pattern은 객체 생성을 캡슐화한다."

알겠다. 근데 지금 내 서비스에 Factory를 넣으면 뭐가 좋아지는지 모르겠다. 다음 요구사항이 들어왔을 때 뭐가 달라지는지 그림이 안 그려진다.

좋다고 들었다. 근데 내 현재 시스템과 연결이 안 된다.

---

SOLID. 좋다고 들었다. 면접에서도 말했다.

"Single Responsibility, Open-Closed, Liskov..."

다 외웠다. 근데 지금 이 클래스가 SRP를 지키는지 아닌지 모르겠다. 지키면 나중에 뭐가 좋아지는지 상상이 안 된다.

좋다고 들었다. 근데 내 현재 문제와 연결이 안 된다.

---

원칙들의 문제는 이거다:

**좋다고 들었다. 믿는다. 근데 내 현재 문제와 연결이 안 된다. 미래에 뭐가 좋아지는지 상상이 안 된다.**

그래서 복붙한다. 지금 되니까. 빠르니까.

---

## 하나의 질문

여기 더 나은 질문이 있다.

**"요구사항이 바뀌면, 이 부분만 교체할 수 있어?"**

이 질문은 다르다.

- 추상적이지 않다
- Yes 또는 No로 답할 수 있다
- 뭘 묻는지, 뭘 의도하는지, 어떻게 확인하는지 안다

"MySQL에서 PostgreSQL로 바꾼다면, 데이터 모델 다 바꿔야 하는 건 아니지?"
"PG사 바꾸면, 결제 모듈만 교체하면 되지?"
"Twilio에서 다른 서비스로 바꾸면, 어디 어디 수정해야 해?"

---

그리고 이 질문은 자동으로 다음 질문을 만든다.

"어떤 상황에서 교체하게 될까?"
"어떻게 교체할 수 있을까?"
"교체하면 뭐가 바뀔까?"

**Replaceability는 개발자들이 다음 문제에 대한 방법을 자연스럽게 상상하게 한다.**

Low Coupling은 이런 상상을 자극하지 않는다. 그냥 상태를 설명할 뿐이다.

---

## 같은 시간, 다른 결과

예시를 보자.

새로운 요청이 들어왔다. 일반 주문 API가 있는데, VIP 주문 API를 추가해달라고 한다. 거의 같다. 할인율만 다르고, 로깅만 다르다.

---

**Replaceable point 없이:**

개발자가 OrderService.java를 복사한다.
VIPOrderService.java를 만든다.
할인율 수정한다.
로깅 수정한다.

OrderRepository.java를 복사한다.
VIPOrderRepository.java를 만든다.

OrderValidator.java를 복사한다.
VIPOrderValidator.java를 만든다.

작동한다. 끝.

- 시간: 2일
- 파일: 6개 추가
- 중복: 90%

---

**Replaceable point 있으면:**

이미 OrderService에 교체 지점이 있다.
- DiscountPolicy (인터페이스)
- OrderLogger (인터페이스)

개발자가 VIPDiscountPolicy.java를 만든다.
VIPOrderLogger.java를 만든다.
설정에서 조합한다.

작동한다. 끝.

- 시간: 2일
- 파일: 2개 추가
- 중복: 0%

---

**둘 다 복붙했다. 둘 다 2일 걸렸다.**

차이는 품질이다.

그리고 다음 요청이 온다. "기업 주문 API도 추가해줘."

첫 번째 개발자: 또 6개 복사. 이제 18개 파일.
두 번째 개발자: 또 2개 추가. 이제 6개 파일.

**Replaceable point가 있으면, 복붙해도 품질이 쌓인다.**

그리고 또 다른 요청이 온다. "모든 주문 로그에 IP 로깅 추가해줘."

첫 번째 개발자: 3개 파일 수정.
두 번째 개발자: 1개 파일 수정.

이후 두 개발자들에게 무슨 일이 더 일어날지 쉽게 상상할 수 있다.

---

## 100개의 고객, 하나의 솔루션

2007년이었다. 아마 2008년이었을 수도 있다.

나는 소프트웨어 솔루션 회사에서 R&D 매니저로 일했다. 우리 제품은 여러 고객사에서 사용됐다. 문제는, 고객마다 다른 버전이 있었다는 것이다.

A 고객용 버전.
B 고객용 버전.
C 고객용 버전.
...

새 기능을 추가하면? 모든 버전에 따로 적용해야 했다.
버그를 고치면? 모든 버전에 따로 고쳐야 했다.

지옥이었다.

---

나는 SWAT팀을 만들었다. 미션은 하나였다.

**"모든 고객을 위한 하나의 솔루션을 만들어라. 기존 고객에게 영향 없이."**

우리는 의존성을 분석하는 것부터 시작했다.
각 부분의 책임을 명확히 정의하고,
책임들 사이의 관계를 정리했다.
그리고 교체 가능한 협력을 위해 필요한 곳에 구멍을 만들었다.
우리는 그것을 "Extension Point"라고 불렀다.

고객마다 다른 부분? Extension Point로 분리.
고객마다 같은 부분? 코어에 유지.

Extension Point 덕분에, 잘 돌아가는 버전을 유지할 수 있었다.

---

결과:

우리는 하나의 솔루션을 얻었다. 100개 이상의 고객을 위한. 그 후 10년 이상 유지됐다.

그리고 그때 나는 SOLID가 뭔지도 몰랐다.

---

나중에 SOLID를 배웠을 때, 깨달았다.

"Extension Point" = Replaceable point.

우리가 발견한 것은, 이론가들이 말한 것과 같았다. 다만 우리는 현실에서 먼저 찾았을 뿐이다.

---

## 궁극적 목표

Low Coupling, High Cohesion, SOLID, Design Pattern...

이것들은 뭘 위한 것인가?

**Replaceability.**

전부 교체 가능하게 만들기 위한 것이다.

- Low Coupling → 연결이 적으면 교체하기 쉽다
- High Cohesion → 관련된 것만 모여 있으면 교체 단위가 명확하다
- SOLID
  - SRP/ISP → 교체 대상의 성격을 정의한다
  - OCP/DIP → 교체를 구현하는 방법을 제공한다
  - LSP → 교체가 동작하는 이론적 배경을 설명한다
- Design Pattern → 교체 지점을 만드는 검증된 방법들이다
- ROD → 교체 단위를 설계한다
- TFD → 교체가 안전한지 검증한다

**Replaceability는 원칙이 아니다. 원칙들의 목표다.**

---

회사에서 OKR을 쓴다면 이해하기 쉽다.

- Objective (목표): 좋은 소프트웨어
- Key Result (핵심 결과): 교체할 수 있는가?

Low Coupling은 Key Result가 아니다. Key Result를 달성하기 위한 방법이다.

**Replaceability가 Key Result다.**

---

## 내일부터

복붙해도 된다. 빠르고, 직관적이고, 현실적이다.

다만, 복붙하기 전에 한 가지만 생각하자.

**"여기에 교체 지점이 있어야 하나?"**

이 질문 하나가:
- 같은 시간으로 더 나은 품질을 만든다
- 다음 문제의 해결책을 상상하게 한다
- "잘 돌아가는 것 건드리지 마"를 유지하면서 변화에 대응하게 한다

---

좋은 소프트웨어란 무엇인가?

**교체할 수 있는 소프트웨어다.**

---

*이 글은 "압박 속에서 품질을 유지하는 소프트웨어 개발 철학" 시리즈의 일부입니다.*

---

**시리즈:**
1. [Why Good Developers Make Bad Decisions Under Pressure]()
2. [ROD: Design Complete, Implement Fast]()
3. [TFD: Requirements = Tests]()
4. [DGTF: Slow is Smooth, Smooth is Fast]()
5. [Putting It All Together]()
6. **Replaceability: 좋은 소프트웨어의 궁극적 목표** ← 지금 여기

---

*Connect with me:*
- *GitHub: [dont-go-too-fast](https://github.com/bakmeon/dont-go-too-fast)*
- *Email: stillblueist@naver.com*
