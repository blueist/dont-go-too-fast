# 왜 좋은 개발자가 압박 속에서 나쁜 결정을 내리는가

## 그리고 내 소프트웨어 개발 방식을 바꾼 세 가지 프레임워크

---

![image](https://i.ibb.co/C5K0Tv1h/02.png)

**금요일 오후 4시.**

매니저가 다가옵니다. "운영 환경에 버그가 있어요. 퇴근 전에 고칠 수 있나요?"

코드를 엽니다. 심장 박동이 빨라집니다. 압박감이 쌓이는 게 느껴집니다.

그리고 그 일이 일어납니다.

전역 변수에 손이 갑니다. 값을 하드코딩합니다. 테스트를 건너뜁니다. 스스로에게 말합니다: "월요일에 제대로 고치지 뭐."

월요일이 옵니다. 잊어버렸습니다. 기술 부채는 남습니다. 이 사이클이 반복됩니다.

**익숙한가요?**

24년간 소프트웨어를 만들면서, 이 패턴이 어떤 기술적 도전보다 더 많은 프로젝트를 망치는 것을 봤습니다. 개발자들의 실력이 부족해서가 아닙니다. 그들이 몰라서가 아닙니다.

압박이 닥치면 우리의 사고에 **무언가**가 일어나기 때문입니다.

---

## 모든 것을 바꾼 발견

개발자 초기 시절, 같은 질문을 계속했습니다: *왜 똑똑한 개발자가 멍청한 결정을 내릴까?*

재능 있는 엔지니어들이—SOLID 원칙을 자면서도 설명할 수 있는 사람들이—마감이 다가오면 빠른 꼼수에 손을 뻗는 것을 봤습니다. 신중하게 설계된 시스템이 배포 전 마지막 몇 주 만에 스파게티 코드로 변하는 것을 봤습니다.

규율 문제라고 생각했습니다. 동기 부여 문제라고. 실력 문제라고.

틀렸습니다.

답은 예상치 못한 곳에서 왔습니다: 노벨 경제학상을 받은 심리학자 **다니엘 카너먼**.

---

## 시스템 1 vs 시스템 2: 나쁜 결정 뒤의 과학

카너먼은 인간에게 두 가지 사고 모드가 있다는 것을 발견했습니다:

**시스템 1: 빠른 사고**
- 자동적이고 무의식적
- 노력이 필요 없음
- 패턴과 직관에 의존
- 스트레스 하에서 지배적

**시스템 2: 느린 사고**
- 의도적이고 의식적
- 집중과 에너지 필요
- 분석적이고 논리적
- 압박 하에서 비활성화

핵심적인 통찰은 이것입니다: **압박 하에서 시스템 1이 장악합니다.**

매니저가 "언제 끝나요?"라고 물어서 심장 박동이 빨라지면, 신중하고 분석적인 시스템 2 사고가 멈춥니다. 빠르고 반응적인 시스템 1이 떠오르는 첫 번째 해결책을 잡습니다.

"전역 변수!"
"싱글톤!"
"하드코딩!"
"테스트는 나중에!"

이것들은 의식적인 결정이 아닙니다. **시스템 1 반응**입니다—빠르고, 자동적이고, 종종 틀립니다.

---

## 진짜 문제는 지식이 아니다

생각해보세요.

클린 코드 원칙을 알고 있습니다. SOLID를 이해합니다. TDD에 대해 들어봤습니다.

**그런데 왜 가장 중요할 때 그것들을 따르지 않나요?**

*무엇*을 해야 하는지 아는 것과 압박 하에서 *어떻게* 하는지 아는 것은 다르기 때문입니다.

```
대부분의 개발자가 아는 것:
✓ 클린 코드
✓ SOLID 원칙
✓ 테스트 주도 개발
✓ 디자인 패턴

대부분의 개발자에게 부족한 것:
✗ 마감이 닥쳤을 때 어떻게 따르는지
✗ 시스템 1 충동을 어떻게 저항하는지
✗ 압박 하에서 어떻게 품질을 유지하는지
```

이 간극—아는 것과 실행하는 것 사이—이 프로젝트가 실패하는 곳입니다.

---

## 세 가지 이론, 하나의 프레임워크

수년간, 퍼즐의 두 조각을 더 찾았습니다.

**도넬라 메도즈**는 시스템 사고를 가르쳐줬습니다—부분만이 아니라 전체를 보는 방법. 가장 강력한 개입 지점은 구현이 시작되기 전, 설계 수준이라는 것을 보여줬습니다.

**겐리히 알츠슐러**는 TRIZ를 가르쳐줬습니다—타협하지 않고 모순을 해결하는 방법. "빠름" 대 "품질"은 트레이드오프처럼 보입니다. 하지만 둘 다 가질 수 있다면?

인간 사고에 대한 카너먼의 통찰과 결합하여, 이 세 이론이 실용적 프레임워크의 기반이 되었습니다:

| 이론 | 답하는 질문 |
|------|-------------|
| 카너먼 | **왜** 나쁜 결정을 내리는가? |
| 메도즈 | **무엇**을 설계해야 하는가? |
| 알츠슐러 | **어떻게** 모순을 해결하는가? |

---

## ROD, TFD, DGTF 소개

이 이론들로부터, 소프트웨어를 만드는 방식을 변화시킨 세 가지 방법론을 개발했습니다:

### ROD: 책임 지향 설계 (Responsibility-Oriented Design)
**"빠지는 것보다 많은 것이 낫다"**

구현 전에 완전한 서비스 체인을 설계합니다. 정확히 무엇을 만들어야 하는지 알면, 구현 중에 혼란이 없습니다. 혼란이 없으면 시스템 1 패닉이 없습니다. 패닉이 없으면 나쁜 결정이 없습니다.

### TFD: 테스트 우선 개발 (Test-First Development)
**"요구사항 = 테스트"**

테스트를 사후 생각이 아니라 명세로 취급합니다. 테스트가 "완료"의 의미를 정의하면, 즉각적인 피드백을 받습니다. 빠른 피드백은 시스템 1 실수가 문제가 되기 전에 잡아냅니다.

### DGTF: 너무 빨리 가지 마라 (Don't Go Too Fast)
**"느린 것이 매끄럽고, 매끄러운 것이 빠르다"**

압박 하에서도 시스템 2 사고를 유지합니다. 시스템 1이 장악하려 할 때 인식합니다. 멈춥니다. 생각합니다. 그리고 행동합니다.

---

## 역설: 느리게 가는 것이 실제로 더 빠르다

가장 놀라웠던 것은 이것입니다:

```
서두르는 개발자 (시스템 1 지배):
├── 1일차: 빠른 코딩, 테스트 없음 (3시간)
├── 2일차: 버그 수정 (4시간)
├── 3일차: 더 많은 버그 (3시간)
├── 4일차: 리팩토링 (5시간)
└── 5일차: 테스트 추가 (2시간)
합계: 17시간, 불안정한 코드

신중한 개발자 (시스템 2 유지):
├── 1일차: 설계 + 테스트 설계 (2시간)
├── 2일차: 신중한 구현 (3시간)
├── 3일차: 통합 테스트 (2시간)
├── 4일차: E2E 테스트 (2시간)
└── 5일차: 문서화 (1시간)
합계: 10시간, 안정적인 코드
```

**신중한 접근은 7시간(41%)을 절약하고 더 나은 코드를 만들어냅니다.**

이것은 이론이 아닙니다. 24년간 수백 개의 프로젝트에서 관찰한 것입니다.

---

## 다음에 이어질 내용

이 글은 ROD, TFD, DGTF를 깊이 탐구하는 시리즈의 첫 번째입니다.

**다음 글**에서는 ROD를 깊이 다룹니다—시스템 1 패닉을 유발하는 "빠진 조각들"을 제거하는 완전한 서비스 체인을 설계하는 방법.

배울 내용:
- "빠지는 것보다 많은 것이 낫다"가 왜 효과적인지
- 혼란을 방지하는 서비스 체인 만드는 방법
- 생성자와 정적 필드 금지가 실제로 도움이 되는 이유
- 운영 시스템의 실제 예시

**목표는 더 열심히 일하는 것이 아닙니다. 더 잘 생각하는 것입니다—모든 것이 빨리 생각하라고 밀어붙일 때도.**

---

## 오늘 해볼 것

다음 글 전에, 이 간단한 연습을 해보세요:

**압박이 쌓이는 것을 느낄 때** (심장 박동 증가, "서둘러" 생각 반복):

1. **인식**: "시스템 1이 활성화되고 있다"
2. **멈춤**: 키보드에서 손을 뗍니다
3. **질문**: "시간이 더 있다면 무엇을 할까?"
4. **실행**: 어쨌든 그것을 합니다

30초 걸립니다. 하지만 몇 시간의 재작업을 절약할 수 있습니다.

---

*이 글은 압박 하에서 소프트웨어 품질을 유지하는 것에 관한 시리즈의 일부입니다. 24년간의 소프트웨어 개발 경험과 카너먼, 메도즈, 알츠슐러의 검증된 이론에 기반합니다.*

**다음: ROD—완전하게 설계하고, 빠르게 구현한다 →**

---

*마감 중에 시스템 1이 장악하는 경험을 한 적이 있나요? 댓글에서 여러분의 이야기를 공유해주세요. 그리고 이 시리즈의 나머지를 위해 팔로우해주세요.*
